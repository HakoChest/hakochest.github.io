<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="theme/pagetoc.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/initial-example.html"><strong aria-hidden="true">2.1.</strong> Initial Example</a></li><li class="chapter-item expanded "><a href="getting-started/flow-control.html"><strong aria-hidden="true">2.2.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="getting-started/osynic-downloader.html"><strong aria-hidden="true">2.3.</strong> Usage Example: OsynicDownloader</a></li></ol></li><li class="chapter-item expanded "><a href="custom-reporter/index.html"><strong aria-hidden="true">3.</strong> Custom Reporter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom-reporter/tui-reporter.html"><strong aria-hidden="true">3.1.</strong> Built-in TuiReporter</a></li><li class="chapter-item expanded "><a href="custom-reporter/cli-reporter-boardcast-mpsc.html"><strong aria-hidden="true">3.2.</strong> Built-in CliReporterBoardcastMpsc</a></li></ol></li><li class="chapter-item expanded "><a href="custom-resolver/index.html"><strong aria-hidden="true">4.</strong> Custom Resolver</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="custom-resolver/url-resolver.html"><strong aria-hidden="true">4.1.</strong> Built-in UrlResolver</a></li><li class="chapter-item expanded "><a href="custom-resolver/osu-beatmap-resolver.html"><strong aria-hidden="true">4.2.</strong> OsuBeatmapResolver</a></li></ol></li><li class="chapter-item expanded "><a href="change-log.html"><strong aria-hidden="true">5.</strong> Change Log</a></li><li class="chapter-item expanded "><a href="roadmap.html"><strong aria-hidden="true">6.</strong> Roadmap</a></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">7.</strong> Appendix</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">8.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="ending.html"><strong aria-hidden="true">9.</strong> Ending</a></li><li class="chapter-item expanded "><a href="reference.html"><strong aria-hidden="true">10.</strong> Reference</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Vielpork</strong> is a Rust-powered HTTP downloader designed for performance and extensibility. It offers:</p>
<ul>
<li>üöÄ Multi-threaded downloads for maximum speed</li>
<li>üìä Multiple built-in reporters to adapt to most scenarios</li>
<li>üì¶ Rich path policy options and template naming support</li>
<li>üîß Customizable resource resolution strategies for different download scenarios</li>
<li>‚èØÔ∏è Support for pausing/resuming both global and individual tasks</li>
</ul>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; GlobalInit
    GlobalInit --&gt; GlobalRunning: start_all()
    GlobalRunning --&gt; GlobalSuspended: pause_all()
    GlobalSuspended --&gt; GlobalRunning: resume_all()
    GlobalRunning --&gt; GlobalStopped: cancel_all()
    GlobalStopped --&gt; [*]
    
    state TaskStates {
        [*] --&gt; TaskPending
        TaskPending --&gt; TaskDownloading: start_task()
        TaskDownloading --&gt; TaskPaused: pause_task()
        TaskPaused --&gt; TaskDownloading: resume_task()
        TaskDownloading --&gt; TaskCanceled: cancel_task()
        TaskDownloading --&gt; TaskCompleted: finish()
        TaskPaused --&gt; TaskCanceled: cancel_task()
        TaskCanceled --&gt; [*]
        TaskCompleted --&gt; [*]
    }
    
    GlobalSuspended --&gt; TaskPaused : propagate
    GlobalStopped --&gt; TaskCanceled : propagate
</pre>
<h2 id="related-projects"><a class="header" href="#related-projects">Related Projects</a></h2>
<ul>
<li><a href="https://crates.io/crates/osynic_downloader">osynic_downloader</a>: A osu beatmapsets downloader lib &amp; TUI application based on vielpork.</li>
</ul>
<h2 id="core-capabilities"><a class="header" href="#core-capabilities">Core Capabilities</a></h2>
<ul>
<li><strong>Multi-threaded Architecture</strong>: Leverage Rust's async runtime for concurrent chunk downloads</li>
<li><strong>Extensible Reporting</strong>:
<ul>
<li>Built-in reporters: TUI progress bar, CLI broadcast mpsc channel</li>
<li>Custom reporter implementation via trait</li>
</ul>
</li>
<li><strong>Smart Resolution</strong>:
<ul>
<li>Custom resolution logic through Resolver trait</li>
</ul>
</li>
<li><strong>Recovery &amp; Resilience</strong>:
<ul>
<li>Resume interrupted downloads</li>
</ul>
</li>
<li><strong>Progress Tracking</strong>:
<ul>
<li>Real-time speed calculations</li>
<li>ETA estimation</li>
<li>Detailed transfer statistics</li>
</ul>
</li>
</ul>
<h2 id="built-in-options"><a class="header" href="#built-in-options">Built-in Options</a></h2>
<h3 id="reporters"><a class="header" href="#reporters">Reporters</a></h3>
<ul>
<li><strong>TuiReporter</strong>: A terminal-based progress bar based on the <code>indicatif</code> library</li>
<li><strong>CliReporterBoardcastMpsc</strong>: A reporter that broadcasts progress updates to multiple channels and finalizes them with a single channel ( Usage Example: In Tonic gRPC server streaming, the rx type can only be mpsc, so we need to broadcast the progress to a mpsc channel, then send it to the client through the server)</li>
</ul>
<h3 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h3>
<ul>
<li><strong>UrlResolver</strong>: A resolver that downloads resources from a URL, just a simple wrapper around reqwest</li>
</ul>
<h2 id="custom-components"><a class="header" href="#custom-components">Custom Components</a></h2>
<p>You can see all traits at <code>vielpork::base::traits</code> and implement your own components.</p>
<h3 id="custom-reporter"><a class="header" href="#custom-reporter">Custom Reporter</a></h3>
<ul>
<li>Here are 2 traits that you need to implement with async_trait:
<ul>
<li><code>ProgressReporter</code>: A trait that allows the reporter to handle progress updates</li>
<li><code>ResultReporter</code>: A trait that allows the reporter to handle the results of operations or tasks</li>
</ul>
</li>
</ul>
<h3 id="custom-resolver"><a class="header" href="#custom-resolver">Custom Resolver</a></h3>
<ul>
<li>Here is only 1 trait that you need to implement with async_trait:
<ul>
<li><code>ResourceResolver</code>: A trait that allows the resolver to download resources from a specific source</li>
</ul>
</li>
</ul>
<h2 id="afterword-or-the-prologue"><a class="header" href="#afterword-or-the-prologue">Afterword (or the prologue)</a></h2>
<p>I found the word &quot;viel&quot; and then thought about &quot;rufen&quot;, &quot;ekstase&quot;, &quot;reichen&quot;.</p>
<p>But when I was still hesitating, a good friend came to my dorm and brought me a cup of smoked pork shreds.</p>
<p>So I named it &quot;vielpork&quot;, which means a lot of pork shreds.</p>
<p>But in terms of functionality, this downloader is mainly about multi-reporting channel downloads, so it's also a lot of reporting.</p>
<p>&quot;report&quot; is very close to &quot;vielpork&quot;, which is also good.</p>
<p>For me, who has been eating free porridge for a week, this name is already very good.</p>
<p>Oh, by the way, spicy boiled pork slices can also be called VielPork. I love it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>The main parts are as follows</p>
<ul>
<li>Initial example</li>
<li>Flow control</li>
<li>Usage example: OsynicDownloader</li>
</ul>
<p>After reading the initial example, you can try to run the example code to download the resources you need.</p>
<p>Then, you can try to customize the Reporter and Resolver.</p>
<ul>
<li>Custom Reporter</li>
<li>Custom Resolver</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-example"><a class="header" href="#initial-example">Initial Example</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
vielpork = &quot;0.1.0&quot;
</code></pre>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust">use vielpork::downloader::Downloader;
use vielpork::reporters::tui::TuiReporter;
use vielpork::resolvers::url::UrlResolver;
use vielpork::base::structs::DownloadOptions;
use vielpork::base::enums::DownloadResource;
use vielpork::error::Result;

use std::sync::Arc;
use tokio::sync::Mutex;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let options: DownloadOptions = DownloadOptions::default()
        .with_save_path(&quot;fetch&quot;.to_string())
        .with_concurrency(3);

    let downloader = Downloader::new(options, Box::new(UrlResolver::new()), Box::new(TuiReporter::new()));

    let resources = vec![
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
        DownloadResource::Url(&quot;https://example.com&quot;.to_string()),
    ];

    downloader.start(resources).await?;

    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // Because of the async nature of the downloader, we need to keep the main thread alive
    }

    Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-control"><a class="header" href="#flow-control">Flow Control</a></h1>
<p><code>vielpork</code> provides a complete flow control method to make it easier for you to control the flow when writing asynchronous code.</p>
<ul>
<li>
<p>Global control</p>
<ul>
<li><code>downloader.lock().await.start(resources).await?;</code></li>
<li><code>downloader.lock().await.pause().await?;</code></li>
<li><code>downloader.lock().await.resume().await?;</code></li>
<li><code>downloader.lock().await.cancel().await?;</code></li>
</ul>
</li>
<li>
<p>Task control</p>
<ul>
<li><code>downloader.lock().await.pause_task(resource).await?;</code></li>
<li><code>downloader.lock().await.resume_task(resource).await?;</code></li>
<li><code>downloader.lock().await.cancel_task(resource).await?;</code></li>
</ul>
</li>
</ul>
<p>Just use it directly in the code, and <code>vielpork</code> will automatically handle the state transitions of the tasks.</p>
<h2 id="state-transition-diagram"><a class="header" href="#state-transition-diagram">State Transition Diagram</a></h2>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; GlobalInit
    GlobalInit --&gt; GlobalRunning: start_all()
    GlobalRunning --&gt; GlobalSuspended: pause_all()
    GlobalSuspended --&gt; GlobalRunning: resume_all()
    GlobalRunning --&gt; GlobalStopped: cancel_all()
    GlobalStopped --&gt; [*]
    
    state TaskStates {
        [*] --&gt; TaskPending
        TaskPending --&gt; TaskDownloading: start_task()
        TaskDownloading --&gt; TaskPaused: pause_task()
        TaskPaused --&gt; TaskDownloading: resume_task()
        TaskDownloading --&gt; TaskCanceled: cancel_task()
        TaskDownloading --&gt; TaskCompleted: finish()
        TaskPaused --&gt; TaskCanceled: cancel_task()
        TaskCanceled --&gt; [*]
        TaskCompleted --&gt; [*]
    }
    
    GlobalSuspended --&gt; TaskPaused : propagate
    GlobalStopped --&gt; TaskCanceled : propagate
</pre>
<h2 id="reasonable-state-transition"><a class="header" href="#reasonable-state-transition">Reasonable State Transition</a></h2>
<p><code>vielpork</code>'s state transition is in the form of a finite state machine, with each task having a state, and each task's state transition is finite. This ensures that the task's state transition is reasonable and that unreasonable state transitions do not occur.</p>
<h3 id="reasonable-global-state-transition"><a class="header" href="#reasonable-global-state-transition">Reasonable Global State Transition</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let valid = match (*current, new_state) {
    (DownloaderState::Idle, DownloaderState::Running) =&gt; true,
    (DownloaderState::Running, DownloaderState::Suspended) =&gt; true,
    (DownloaderState::Suspended, DownloaderState::Running) =&gt; true,
    (DownloaderState::Running, DownloaderState::Stopped) =&gt; true,
    (DownloaderState::Suspended, DownloaderState::Stopped) =&gt; true,
    _ =&gt; false,
};
<span class="boring">}
</span></code></pre></pre>
<h3 id="reasonable-task-state-transition"><a class="header" href="#reasonable-task-state-transition">Reasonable Task State Transition</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let valid = match (*current, new_state) {
    (TaskState::Pending, TaskState::Paused) =&gt; true,
    (TaskState::Paused, TaskState::Pending) =&gt; true,
    (TaskState::Paused, TaskState::Paused) =&gt; true,
    (TaskState::Pending, TaskState::Downloading) =&gt; true,
    (TaskState::Downloading, TaskState::Paused) =&gt; true,
    (TaskState::Paused, TaskState::Downloading) =&gt; true,
    (TaskState::Downloading, TaskState::Completed) =&gt; true,
    (TaskState::Downloading, TaskState::Failed) =&gt; true,
    (TaskState::Failed,_) =&gt; true,
    (_, TaskState::Canceled) =&gt; true,
    _ =&gt; false,
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-example-osynicdownloader"><a class="header" href="#usage-example-osynicdownloader">Usage Example: OsynicDownloader</a></h1>
<p><a href="https://crates.io/crates/osynic_downloader">osynic_downloader</a> is an efficient osu! beatmap downloader tool based on <a href="https://crates.io/crates/vielpork">vielpork</a>, supporting two input formats and parallel downloading, designed for rhythm game players and beatmap managers.</p>
<p>Recommended to use with <a href="https://crates.io/crates/osynic_serializer">osynic_serializer</a> to achieve fast serialization of osu! beatmaps.</p>
<p><img src="https://s2.loli.net/2025/03/10/hasqOmgctyG4TWd.gif" alt="osynic_downloader.gif" /></p>
<h2 id="-features"><a class="header" href="#-features">‚ú® Features</a></h2>
<ul>
<li><strong>Dual-mode input</strong>: Supports native osu! beatmap set ID list and custom Osynic serialization generated format</li>
<li><strong>Multiple download sources</strong>: Currently supports four download sources: OsuDirect, OsuApiV2, SayoApi, and ChimuApi</li>
<li><strong>Concurrency support</strong>: Multi-threaded concurrent downloading acceleration (default 4 threads) (please note the concurrency limit of various osu! mirror site APIs! Use it properly!)</li>
<li><strong>Intelligent management</strong>: Automatically create directory structure, custom save path</li>
<li><strong>Visual progress</strong>: Real-time TUI progress display (supports terminal 256 colors)</li>
<li><strong>Error recovery</strong>: State recovery mechanism ensures download integrity</li>
</ul>
<h2 id="-installation"><a class="header" href="#-installation">üì¶ Installation</a></h2>
<h3 id="precompiled-version"><a class="header" href="#precompiled-version">Precompiled version</a></h3>
<pre><code class="language-bash">cargo install osynic_downloader
</code></pre>
<h3 id="source-code-compilation"><a class="header" href="#source-code-compilation">Source code compilation</a></h3>
<pre><code class="language-bash">git clone https://github.com/osynicite/osynic_downloader
cd osynic_downloader
cargo build --release
</code></pre>
<h2 id="-quick-start"><a class="header" href="#-quick-start">üöÄ Quick Start</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h3>
<pre><code class="language-bash"># Native mode (ID list)
osynic-dl --beatmapsets json/sets.json -o ./osu_maps -c 8
# Osynic mode (song metadata)
osynic-dl --osynic-songs json/songs.json --output ./music
</code></pre>
<h3 id="configuration-file-example"><a class="header" href="#configuration-file-example">Configuration file example</a></h3>
<p><strong>sets.json</strong> (native mode):</p>
<pre><code class="language-json">{
    &quot;beatmapset_ids&quot;: [&quot;114514&quot;, &quot;1919810&quot;, &quot;1538879&quot;]
}
</code></pre>
<p><strong>songs.json</strong> (Osynic mode):</p>
<pre><code class="language-json">[
  {
    &quot;song_id&quot;: 1985060,
    &quot;artist_name&quot;: &quot;„Éí„Éà„É™„Ç®&quot;,
    &quot;mapper_name&quot;: &quot;flake&quot;,
    &quot;song_name&quot;: &quot;Êó•Â∏∏„Å®Âú∞ÁêÉ„ÅÆÈ°çÁ∏Å (wowaka x ÂàùÈü≥„Éü„ÇØ Edit)&quot;,
    &quot;no_video&quot;: false
  },
    {
    &quot;song_id&quot;: 1997071,
    &quot;artist_name&quot;: &quot;„Éä„Éñ„Éä&quot;,
    &quot;mapper_name&quot;: &quot;Ryuusei Aika&quot;,
    &quot;song_name&quot;: &quot;ÂßãÁô∫„Å®„Ç´„Éï„Ç´&quot;,
    &quot;no_video&quot;: false
  }
]
</code></pre>
<h2 id="-command-line-options"><a class="header" href="#-command-line-options">üìú Command Line Options</a></h2>
<table><thead><tr><th>Option</th><th>Short</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td>--beatmapsets</td><td>-b</td><td>-</td><td>Path to native mode JSON file</td></tr>
<tr><td>--osynic-songs</td><td>-n</td><td>-</td><td>Path to Osynic mode JSON file</td></tr>
<tr><td>--source</td><td>-s</td><td>SayoApi</td><td>osu! beatmap download source</td></tr>
<tr><td>--username</td><td>-u</td><td>-</td><td>osu! account (only for OsuDirect/OsuApiV2)</td></tr>
<tr><td>--password</td><td>-p</td><td>-</td><td>osu! password (only for OsuDirect/OsuApiV2)</td></tr>
<tr><td>--output</td><td>-o</td><td>beatmapsets</td><td>Download directory (auto-created)</td></tr>
<tr><td>--concurrency</td><td>-c</td><td>4</td><td>Download concurrency (1-16)</td></tr>
<tr><td>--help</td><td>-h</td><td>-</td><td>Display help information</td></tr>
</tbody></table>
<h2 id="supported-osu-download-sources"><a class="header" href="#supported-osu-download-sources">Supported osu! Download Sources</a></h2>
<ol>
<li><strong>OsuDirect</strong>: Official osu! beatmap download source (osu username and password required)</li>
<li><strong>OsuApiV2</strong>: osu!lazer beatmap download source (osu username and password required, Basic authentication)</li>
<li><strong>SayoApi</strong> (default): Sayobot beatmap download source (no login required)</li>
<li><strong>ChimuApi</strong>: Chimu.moe beatmap download source (no login required)</li>
</ol>
<h2 id="-notes"><a class="header" href="#-notes">üìå Notes</a></h2>
<ol>
<li>Video download adaptation (no_video) is not yet implemented, and related options will be ignored</li>
<li>Download file naming follows the <code>{{filename}}</code> naming rule</li>
<li>Interrupting the download process with <code>Ctrl+C</code> and then rerunning will resume the download</li>
<li>It is recommended to use a stable network connection for the best experience</li>
</ol>
<h2 id="-contributing"><a class="header" href="#-contributing">ü§ù Contributing</a></h2>
<p>Contributions are welcome! Please follow these guidelines:</p>
<ul>
<li>Follow the official Rust coding style</li>
<li>Add test cases for new features</li>
<li>Run <code>cargo fmt</code> and <code>cargo clippy</code> before submitting</li>
</ul>
<h2 id="-license"><a class="header" href="#-license">üìú License</a></h2>
<p>This project is open-sourced under the <a href="getting-started/LICENSE">MIT License</a>. Please respect the original author's copyright. When using osu! related resources, please follow the <a href="https://osu.ppy.sh/wiki/zh/Legal">osu! community guidelines</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-reporter-1"><a class="header" href="#custom-reporter-1">Custom Reporter</a></h1>
<p>In <code>vielpork</code>, Reporter is an interface used to report the progress and results of download tasks to the outside. Reporter consists of two traits, which define a series of methods for reporting the progress and results of download tasks to the outside. The implementation of Reporter can be any type, as long as it implements these two Reporter traits.</p>
<p>The two traits defined in <code>vielport::base::traits</code> are <code>ProgressReporter</code> and <code>ResultReporter</code>. <code>ProgressReporter</code> defines three methods for reporting the start, progress update, and end of download tasks. <code>ResultReporter</code> defines a method for reporting the result of download tasks.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait ProgressReporter
{
    async fn start_task(&amp;self, task_id: u32, total: u64) -&gt; Result&lt;()&gt;;
    async fn update_progress(&amp;self, task_id: u32, progress: &amp;DownloadProgress) -&gt; Result&lt;()&gt;;
    async fn finish_task(&amp;self, task_id: u32, result: DownloadResult) -&gt; Result&lt;()&gt;;
}

#[async_trait]
pub trait ResultReporter
{
    async fn operation_result(&amp;self, operation: OperationType, code: u32, message: String) -&gt; Result&lt;()&gt;;
}

pub trait CombinedReporter: ProgressReporter + ResultReporter + Send + Sync {}
impl&lt;T: ProgressReporter + ResultReporter + Send + Sync&gt; CombinedReporter for T {}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-usage-example-one-tuireporter"><a class="header" href="#internal-usage-example-one-tuireporter">Internal Usage Example One: TuiReporter</a></h1>
<p><code>vielpork</code> provides a built-in TUI reporter <code>TuiReporter</code> for displaying the progress of download tasks in the terminal. <code>TuiReporter</code> implements two traits, <code>ProgressReporter</code> and <code>ResultReporter</code>, to report the progress and results of download tasks to the outside world.</p>
<p><code>TuiReporter</code> uses the <code>indicatif</code> library to display the progress of download tasks. When a download task starts, <code>TuiReporter</code> creates a new progress bar and updates the status of the progress bar when the download task ends. <code>TuiReporter</code> also reports the result of the download task to the outside world when the download task ends.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use crate::error::Result;
use crate::base::structs::DownloadProgress;
use crate::base::enums::{DownloadResult, OperationType};
use crate::base::traits::{ProgressReporter, ResultReporter};
use async_trait::async_trait;


#[cfg(feature = &quot;tui&quot;)]
use indicatif::{ProgressBar, ProgressStyle,ProgressDrawTarget,MultiProgress};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;

const MAX_CONCURRENT_BARS: usize = 10 ;

// TUI ÂÆûÁé∞
#[cfg(feature = &quot;tui&quot;)]
#[derive(Debug)]
pub struct TuiReporter {
    mp: MultiProgress,
    bars: Arc&lt;Mutex&lt;HashMap&lt;u32, ProgressBar&gt;&gt;&gt;,
}

impl TuiReporter {
    pub fn new() -&gt; Self {
        let mp = Self::setup_global_progress();
        Self {
            mp,
            bars: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    fn setup_global_progress() -&gt; MultiProgress {
        let mp = MultiProgress::new();
        mp.set_draw_target(ProgressDrawTarget::stdout());
        mp
    }

    // ÁßÅÊúâÊñπÊ≥ïÁî®‰∫éËé∑ÂèñÊàñÂàõÂª∫ËøõÂ∫¶Êù°
    async fn get_or_create_bar(&amp;self, task_id: u32, total: u64) -&gt; ProgressBar {
        let mut bars = self.bars.lock().await;
        
        if bars.len() &gt;= MAX_CONCURRENT_BARS {
            bars.retain(|_, bar| !bar.is_finished());
        }

        bars.entry(task_id)
            .or_insert_with(|| {
                let bar = ProgressBar::new(total);
                // ÂÖ≥ÈîÆ‰øÆÊîπÔºöÂ∞ÜËøõÂ∫¶Êù°Ê∑ªÂä†Âà∞ MultiProgress Á≥ªÁªü
                let bar = self.mp.add(bar); // ËøôË°åÊòØÊ†∏ÂøÉ‰øÆÊîπ
                bar.set_style(ProgressStyle::with_template(&amp;format!(
                    &quot;{{spinner:.green}} [{{bar:.cyan/blue}}] {{bytes}}/{{total_bytes}} ({}) {{msg}}&quot;,
                    task_id
                ))
                .unwrap_or(ProgressStyle::default_bar())
                .progress_chars(&quot;#&gt;-&quot;));
                bar
            });
        
        bars.get(&amp;task_id).unwrap_or(&amp;ProgressBar::hidden()).clone()
    }
}


#[async_trait]
impl ProgressReporter for TuiReporter {
    async fn start_task(&amp;self, task_id: u32, total: u64) -&gt; Result&lt;()&gt; {
        let bar = self.get_or_create_bar(task_id, total).await;
        bar.set_message(&quot;Downloading...&quot;);
        Ok(())
    }

    async fn update_progress(&amp;self, task_id: u32, progress: &amp;DownloadProgress) -&gt; Result&lt;()&gt; {
        let bar = self.get_or_create_bar(task_id, progress.total_bytes).await;
        bar.set_position(progress.bytes_downloaded);

        let speed = if progress.rate &gt; 1_000_000.0 {
            format!(&quot;{:.2} MB/s&quot;, progress.rate / 1_000_000.0)
        } else if progress.rate &gt; 1_000.0 {
            format!(&quot;{:.2} KB/s&quot;, progress.rate / 1_000.0)
        } else {
            format!(&quot;{:.0} B/s&quot;, progress.rate)
        };

        // Ê†ºÂºèÂåñÂâ©‰ΩôÊó∂Èó¥
        let eta = if progress.remaining_time.as_secs() &gt; 60 {
            format!(&quot;{}m {}s&quot;, 
                progress.remaining_time.as_secs() / 60,
                progress.remaining_time.as_secs() % 60)
        } else {
            format!(&quot;{}s&quot;, progress.remaining_time.as_secs())
        };
        
        bar.set_message(format!(&quot;Speed: {} | ETA: {}&quot;, speed,eta));

        
        Ok(())
    }

    async fn finish_task(&amp;self, task_id: u32,result: DownloadResult) -&gt; Result&lt;()&gt; {
        let mut bars = self.bars.lock().await;
        if let Some(bar) = bars.remove(&amp;task_id) {
            match result {
                DownloadResult::Success { path ,duration ,.. } =&gt; {
                    // Êù°ÁöÑÈ¢úËâ≤ÂèòÊàêÁªøËâ≤ÔºåËøòÊòØ#&gt;-
                    bar.set_style(ProgressStyle::with_template(&amp;format!(
                        &quot;{{spinner:.green}} [{{bar:.green/blue}}] {{bytes}}/{{total_bytes}} ({}): {{msg}}&quot;,
                        task_id
                    ))?.progress_chars(&quot;#&gt;-&quot;));
                    let success_message = format!(&quot;‚úÖ Done in {}s, saved to {}&quot;,duration.as_secs(),path.display());
                    bar.finish_with_message(success_message)
                },
                DownloadResult::Failed { error,.. } =&gt; {
                    // Êù°ÂèòÊàêÁ∫¢Ëâ≤
                    bar.set_style(ProgressStyle::default_bar().template(&amp;format!(
                        &quot;{{spinner:.red}} [{{bar:.red/blue}}] {{bytes}}/{{total_bytes}} ({}): {{msg}}&quot;,
                        task_id
                    ))?.progress_chars(&quot;#&gt;-&quot;));
                    let error_message = format!(&quot;‚ùå Error: {}&quot;, error);
                    bar.abandon_with_message(error_message)
                },
                DownloadResult::Canceled =&gt; {
                    // Êù°ÂèòÊàêÈªÑËâ≤
                    bar.set_style(ProgressStyle::default_bar().template(&amp;format!(
                        &quot;{{spinner:.red}} [{{bar:.yellow/blue}}] {{bytes}}/{{total_bytes}} ({}): {{msg}}&quot;,
                        task_id
                    ))?.progress_chars(&quot;#&gt;-&quot;));
                    bar.abandon_with_message(&quot;‚õî Canceled&quot;)
                },
            }
        }
        Ok(())
    }
}

#[async_trait]
impl ResultReporter for TuiReporter {
    async fn operation_result(&amp;self, operation: OperationType, code: u32, message: String) -&gt; Result&lt;()&gt; {
        if code == 200 {
            println!(&quot;{}: {}&quot;, operation, message);
        } else {
            eprintln!(&quot;{}: {}&quot;, operation, message);
        }
        Ok(())
    }
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-usage-example-two-clireporterboardcastmpsc"><a class="header" href="#internal-usage-example-two-clireporterboardcastmpsc">Internal Usage Example Two: CliReporterBoardcastMpsc</a></h1>
<p><code>vielpork</code> provides a built-in CLI broadcast reporter <code>CliReporterBoardcastMpsc</code> for broadcasting the progress of download tasks to multiple mpsc channels. <code>CliReporterBoardcastMpsc</code> implements two traits, <code>ProgressReporter</code> and <code>ResultReporter</code>, to report the progress and results of download tasks to the outside world.</p>
<p><code>CliReporterBoardcastMpsc</code> uses <code>tokio::sync::mpsc</code> to broadcast the progress of download tasks. When a download task starts, <code>CliReporterBoardcastMpsc</code> sends progress update messages to multiple mpsc channels, and reports the result of the download task to the outside world when the download task ends.</p>
<p>This reporter's implementation is relatively simple, only need to send messages to multiple mpsc channels in the methods of <code>ProgressReporter</code> and <code>ResultReporter</code>. It was originally used to solve the problem that the rx type in Tonic gRPC server stream can only be mpsc, so we need to broadcast the progress to mpsc channels and then send it to the client through the server.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::error::Result;
use crate::base::traits::{ProgressReporter, ResultReporter};
use crate::base::structs::DownloadProgress;
use crate::base::enums::{ProgressEvent, DownloadResult, OperationType};
use async_trait::async_trait;

#[derive(Debug,Clone)]
pub struct CliReporterBoardcastMpsc{
    inner_tx: tokio::sync::broadcast::Sender&lt;ProgressEvent&gt;,
    buffer_size: usize,
}
impl CliReporterBoardcastMpsc {
    pub fn new(buffer_size: usize) -&gt; Self {
        let (inner_tx, _) = tokio::sync::broadcast::channel(buffer_size);
        Self { inner_tx, buffer_size }
    }

    pub fn subscribe_mpsc(&amp;self) -&gt; tokio::sync::mpsc::Receiver&lt;ProgressEvent&gt; {
        let (tx, rx) = tokio::sync::mpsc::channel(self.buffer_size);
        let mut inner_rx = self.inner_tx.subscribe();
        
        tokio::spawn(async move {
            loop {
                match inner_rx.recv().await {
                    Ok(event) =&gt; {
                        if tx.send(event).await.is_err() {
                            break;
                        }
                    }
                    Err(_) =&gt; {
                        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                    }
                }
            }
        });
        
        rx
    }

    // ÂèëÈÄÅ‰∫ã‰ª∂ÁöÑÊñπÊ≥ï
    pub async fn send(&amp;self, event: ProgressEvent) -&gt; Result&lt;usize&gt; {
        self.inner_tx.send(event)?;
        Ok(self.inner_tx.receiver_count())
    }

    // ÂàõÂª∫Êñ∞ËÆ¢ÈòÖËÄÖ
    pub fn subscribe(&amp;self) -&gt; tokio::sync::broadcast::Receiver&lt;ProgressEvent&gt; {
        self.inner_tx.subscribe()
    }
}

#[async_trait]
impl ProgressReporter for CliReporterBoardcastMpsc {
    async fn start_task(&amp;self, task_id: u32, total: u64) -&gt;Result&lt;()&gt; {
        self.send(ProgressEvent::Start { task_id, total }).await?;
        Ok(())
    }

    async fn update_progress(&amp;self, task_id: u32, progress: &amp;DownloadProgress)-&gt;Result&lt;()&gt; {
        self.send(ProgressEvent::Update { task_id, progress: progress.clone() }).await?;
        Ok(())
    }

    async fn finish_task(&amp;self, task_id: u32,finish: DownloadResult) -&gt;Result&lt;()&gt;{
        self.send(ProgressEvent::Finish { task_id ,finish}).await?;
        Ok(())
    }
}

#[async_trait]
impl ResultReporter for CliReporterBoardcastMpsc {
    async fn operation_result(&amp;self, operation: OperationType, code: u32, message: String) -&gt;Result&lt;()&gt; {
        self.send(ProgressEvent::OperationResult { operation, code, message }).await?;
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resolver-1"><a class="header" href="#custom-resolver-1">Custom Resolver</a></h1>
<p>In <code>vielpork</code>, <code>Resolver</code> is a trait used to resolve the source of resources. <code>vielpork</code> provides a built-in <code>UrlResolver</code> for downloading resources from URLs. You can customize the resolution logic by implementing the <code>Resolver</code> trait.</p>
<p>The trait defined in <code>vielport::base::traits</code> is <code>ResourceResolver</code>. <code>ResourceResolver</code> defines a method for resolving the source of resources.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait ResourceResolver: Send + Sync {
    async fn resolve(&amp;self, resource: &amp;DownloadResource) -&gt; Result&lt;ResolvedResource&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="what-are-resolvers-for"><a class="header" href="#what-are-resolvers-for">What Are Resolvers For?</a></h2>
<p><code>Resolver</code> is used to convert <code>DownloadResource</code> to <code>ResolvedResource</code>. <code>DownloadResource</code> is an enum type that contains different types of resources. <code>ResolvedResource</code> is a struct that contains detailed information required for an HTTP request.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `DownloadResource` enum type defined in `vielpork::base::enums`

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DownloadResource {
    Url(String),
    Id(String), 
    Params(Vec&lt;String&gt;),
    HashMap(HashMap&lt;String, String&gt;),
    Resolved(ResolvedResource),
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `ResolvedResource` struct defined in `vielpork::base::structs`
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResolvedResource {
    pub id: u32,
    pub url: String,
    pub headers: Vec&lt;(String, String)&gt;,
    pub auth: Option&lt;AuthMethod&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>In this context, <code>AuthMethod</code> supports three authentication methods: <code>Basic</code>, <code>Bearer</code>, and<code>ApiKey</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The `AuthMethod` enum type defined in `vielpork::base::enums`

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum AuthMethod {
    None,
    Basic { username: String, password: String },
    Bearer { token: String },
    ApiKey { key: String, header: String },
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-usage-example-one-urlresolver"><a class="header" href="#internal-usage-example-one-urlresolver">Internal Usage Example One: UrlResolver</a></h1>
<p><code>UrlResolver</code> is a simple resolver that downloads resources from a URL.</p>
<p>In fact, <code>UrlResolver</code> is just a simple reqwest wrapper that converts a URL to a <code>ResolvedResource</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use crate::error::Result;
use crate::base::traits::ResourceResolver;
use crate::base::structs::ResolvedResource;
use crate::base::enums::DownloadResource;
use crate::base::algorithms::generate_task_id;
use async_trait::async_trait;

#[derive(Debug,Clone)]
pub struct UrlResolver {}

impl UrlResolver {
    pub fn new() -&gt; Self {
        Self {}
    }
}

#[async_trait]
impl ResourceResolver for UrlResolver {
    async fn resolve(&amp;self, resource: &amp;DownloadResource) -&gt; Result&lt;ResolvedResource&gt; {
        match resource {
            DownloadResource::Url(url) =&gt; {
                Ok(ResolvedResource{
                    id: generate_task_id(url),
                    url: url.clone(),
                    headers: vec![],
                    auth: None,
                })
            }
            DownloadResource::Resolved(resolved) =&gt; {
                Ok(resolved.clone())
            }
            _ =&gt; {
                Err(&quot;Unsupported resource type&quot;.into())
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-usage-example-1-osubeatmapresolver"><a class="header" href="#external-usage-example-1-osubeatmapresolver">External Usage Example 1: OsuBeatmapResolver</a></h1>
<p>This part can be seen in the source code of <a href="https://crates.io/crates/osynic_downloader">osynic_downloader</a>.</p>
<p><code>osynic_downloader</code> is an osu! beatmap downloader based on <code>vielpork</code>, containing a utility library and a TUI application.</p>
<p>The Resolver it uses is <code>OsuBeatmapResolver</code>, which is a resource resolver that downloads beatmaps from the official osu! website, API, and various mirror sites.</p>
<p>For example:</p>
<ul>
<li>For Url type resources, return the Url directly;</li>
<li>For Id type resources, generate the Url based on the Id, and use the default download source;</li>
<li>For Params type resources, generate the Url based on the parameters, and use the download source specified by the parameters;</li>
<li>For HashMap type resources, generate the Url based on the HashMap, and use the download source specified by the parameters.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use vielpork::base::traits::ResourceResolver;
use vielpork::base::structs::ResolvedResource;
use vielpork::base::enums::{DownloadResource,AuthMethod};
use vielpork::base::algorithms::generate_task_id;
use async_trait::async_trait;

use crate::sources::{DownloadSource, DownloadSourceType};
use crate::url::form_url;

#[derive(Debug,Clone)]
pub struct OsuBeatmapsetResolver {}

impl OsuBeatmapsetResolver {
    pub fn new() -&gt; Self {
        Self {}
    }
}

#[async_trait]
impl ResourceResolver for OsuBeatmapsetResolver {
    async fn resolve(&amp;self, resource: &amp;DownloadResource) -&gt; vielpork::error::Result&lt;ResolvedResource&gt; {
        match resource {
            DownloadResource::Url(url) =&gt; {
                Ok(ResolvedResource{
                    id: generate_task_id(url),
                    url: url.clone(),
                    headers: vec![],
                    auth: None,
                })
            }
            DownloadResource::Id(id) =&gt; {
                let beatmapset_id: u32;
                match id.parse::&lt;u32&gt;() {
                    Ok(id) =&gt; {
                        beatmapset_id = id;
                    }
                    Err(_) =&gt; {
                        return Err(&quot;Invalid beatmapset id&quot;.into());
                    }
                }
                let download_source = DownloadSource::from(DownloadSourceType::Default);
                let base_url = download_source.base_url.clone();
                let url = form_url(&amp;base_url, &amp;beatmapset_id, &quot;&quot;, &quot;&quot;).map_err(|e| e.to_string())?;
                Ok(ResolvedResource{
                    id: beatmapset_id,
                    url: url.clone(),
                    headers: vec![],
                    auth: None,
                })
            }
            DownloadResource::Params(params) =&gt; {
                let beatmapset_id: u32;
                let source: String;

                match params.get(0) {
                    Some(id) =&gt; {
                        match id.parse::&lt;u32&gt;() {
                            Ok(id) =&gt; {
                                beatmapset_id = id;
                            }
                            Err(_) =&gt; {
                                return Err(&quot;Invalid beatmapset id&quot;.into());
                            }
                        }
                    }
                    None =&gt; {
                        return Err(&quot;Missing beatmapset_id&quot;.into());
                    }
                }
                match params.get(1) {
                    Some(src) =&gt; {
                        source = src.clone();
                    }
                    None =&gt; {
                        return Err(&quot;Missing source&quot;.into());
                    }
                }
                let download_source = DownloadSource::from(DownloadSourceType::from(source));
                let base_url = download_source.base_url.clone();

                let username: String;
                let password: String;

                let url: String;
                if download_source.requires_osu_credentials {
                    match params.get(2) {
                        Some(name) =&gt; {
                            username = name.clone();
                        }
                        None =&gt; {
                            return Err(&quot;Missing username&quot;.into());
                        }
                    }
                    match params.get(3) {
                        Some(pass) =&gt; {
                            password = pass.clone();
                        }
                        None =&gt; {
                            return Err(&quot;Missing password&quot;.into());
                        }
                    }
                    if download_source.requires_basic_auth{
                        url = form_url(&amp;base_url, &amp;beatmapset_id, &quot;&quot;,&quot;&quot;).map_err(|e| e.to_string())?;
                        Ok(
                            ResolvedResource{
                                id:beatmapset_id,
                                url: url.clone(),
                                headers: vec![],
                                auth: Some(AuthMethod::Basic { username, password }),
                            }
                        )
                    } else {
                        let hashed_password = format!(&quot;{:x}&quot;, md5::compute(password));
                        url = form_url(&amp;base_url, &amp;beatmapset_id, &amp;username, &amp;hashed_password).map_err(|e| e.to_string())?;
                        Ok(
                            ResolvedResource{
                                id:beatmapset_id,
                                url: url.clone(),
                                headers: vec![],
                                auth: None,
                            }
                        )
                    }
                } else {
                    url = form_url(&amp;base_url, &amp;beatmapset_id, &quot;&quot;, &quot;&quot;).map_err(|e| e.to_string())?;
                    Ok(
                        ResolvedResource{
                            id:beatmapset_id,
                            url: url.clone(),
                            headers: vec![],
                            auth: None,
                        }
                    )
                }

            }
            DownloadResource::HashMap(hashmap) =&gt; {
                let beatmapset_id: u32;
                let source: String;
                match hashmap.get(&quot;beatmapset_id&quot;) {
                    Some(id) =&gt; {
                        match id.parse::&lt;u32&gt;() {
                            Ok(id) =&gt; {
                                beatmapset_id = id;
                            }
                            Err(_) =&gt; {
                                return Err(&quot;Invalid beatmapset id&quot;.into());
                            }
                        }
                    }
                    None =&gt; {
                        return Err(&quot;Missing beatmapset_id&quot;.into());
                    }
                }
                match hashmap.get(&quot;source&quot;) {
                    Some(src) =&gt; {
                        source = src.clone();
                    }
                    None =&gt; {
                        return Err(&quot;Missing source&quot;.into());
                    }
                }
                let download_source = DownloadSource::from(DownloadSourceType::from(source));
                let base_url = download_source.base_url.clone();

                let username: String;
                let password: String;

                let url: String;
                if download_source.requires_osu_credentials {
                    match hashmap.get(&quot;username&quot;) {
                        Some(name) =&gt; {
                            username = name.clone();
                        }
                        None =&gt; {
                            return Err(&quot;Missing username&quot;.into());
                        }
                    }
                    match hashmap.get(&quot;password&quot;) {
                        Some(pass) =&gt; {
                            password = pass.clone();
                        }
                        None =&gt; {
                            return Err(&quot;Missing password&quot;.into());
                        }
                    }
                    if download_source.requires_basic_auth{
                        url = form_url(&amp;base_url, &amp;beatmapset_id, &quot;&quot;,&quot;&quot;).map_err(|e| e.to_string())?;
                        Ok(
                            ResolvedResource{
                                id:beatmapset_id,
                                url: url.clone(),
                                headers: vec![],
                                auth: Some(AuthMethod::Basic { username, password }),
                            }
                        )
                    } else {
                        let hashed_password = format!(&quot;{:x}&quot;, md5::compute(password));
                        url = form_url(&amp;base_url, &amp;beatmapset_id, &amp;username, &amp;hashed_password).map_err(|e| e.to_string())?;
                        Ok(
                            ResolvedResource{
                                id:beatmapset_id,
                                url: url.clone(),
                                headers: vec![],
                                auth: None,
                            }
                        )
                    }
                } else {
                    url = form_url(&amp;base_url, &amp;beatmapset_id, &quot;&quot;, &quot;&quot;).map_err(|e| e.to_string())?;
                    Ok(
                        ResolvedResource{
                            id:beatmapset_id,
                            url: url.clone(),
                            headers: vec![],
                            auth: None,
                        }
                    )
                }                
            }
            DownloadResource::Resolved(resolved) =&gt; {
                Ok(resolved.clone())
            }
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="change-log"><a class="header" href="#change-log">Change Log</a></h1>
<h2 id="01"><a class="header" href="#01">0.1</a></h2>
<ul>
<li>Extracted the common HTTP downloader logic from the <code>download</code> module of <code>osynic_core</code>, and after supporting custom Reporter and Resolver, made it an independent library <code>vielpork</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>There are no more plans for the time being, please stay tuned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="state-diagrams"><a class="header" href="#state-diagrams">State Diagrams</a></h2>
<pre class="mermaid">stateDiagram-v2
    [*] --&gt; GlobalInit
    GlobalInit --&gt; GlobalRunning: start_all()
    GlobalRunning --&gt; GlobalSuspended: pause_all()
    GlobalSuspended --&gt; GlobalRunning: resume_all()
    GlobalRunning --&gt; GlobalStopped: cancel_all()
    GlobalStopped --&gt; [*]
    
    state TaskStates {
        [*] --&gt; TaskPending
        TaskPending --&gt; TaskDownloading: start_task()
        TaskDownloading --&gt; TaskPaused: pause_task()
        TaskPaused --&gt; TaskDownloading: resume_task()
        TaskDownloading --&gt; TaskCanceled: cancel_task()
        TaskDownloading --&gt; TaskCompleted: finish()
        TaskPaused --&gt; TaskCanceled: cancel_task()
        TaskCanceled --&gt; [*]
        TaskCompleted --&gt; [*]
    }
    
    GlobalSuspended --&gt; TaskPaused : propagate
    GlobalStopped --&gt; TaskCanceled : propagate
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshoting"><a class="header" href="#troubleshoting">Troubleshoting</a></h1>
<p>If you have any questions, please issue it.</p>
<p>If you want to contribute, please fork it and pull request.</p>
<p>If you want to contact me, you can email me: <code>zoneherobrine@gmail.com</code>;</p>
<p>or by Tencent QQ: 2212540603 (with related information in the friend request)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ending"><a class="header" href="#ending">Ending</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="theme/pagetoc.js"></script>
                <script type="text/javascript" src="theme/mermaid.min.js"></script>
                <script type="text/javascript" src="theme/mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
